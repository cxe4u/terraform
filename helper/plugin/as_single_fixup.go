package plugin

import (
	"github.com/hashicorp/terraform/helper/schema"
	"github.com/hashicorp/terraform/terraform"
)

// fixupAsSingleResourceConfigIn modifies the given ResourceConfig in-place if
// any attributes in the schema have the AsSingle flag set, wrapping the given
// values for these in an extra level of slice so that they can be understood
// by legacy SDK code that'll be expecting to decode into a list/set.
func fixupAsSingleResourceConfigIn(rc *terraform.ResourceConfig, r *schema.Resource) {
	fixupAsSingleConfigValueIn(rc.Config, r.Schema)
}

// fixupAsSingleInstanceStateIn modifies the given InstanceState in-place if
// any attributes in the schema have the AsSingle flag set, adding additional
// index steps to the flatmap keys for these so that they can be understood
// by legacy SDK code that'll be expecting to decode into a list/set.
func fixupAsSingleInstanceStateIn(is *terraform.InstanceState, r *schema.Resource) {
}

// fixupAsSingleInstanceStateOut modifies the given InstanceState in-place if
// any attributes in the schema have the AsSingle flag set, removing unneeded
// index steps from the flatmap keys for these so that they can be understood
// by the shim back to Terraform Core as a single nested value.
func fixupAsSingleInstanceStateOut(is *terraform.InstanceState, r *schema.Resource) {
}

// fixupAsSingleInstanceDiffIn modifies the given InstanceDiff in-place if any
// attributes in the schema have the AsSingle flag set, adding additional index
// steps to the flatmap keys for these so that they can be understood by legacy
// SDK code that'll be expecting to decode into a list/set.
func fixupAsSingleInstanceDiffIn(id *terraform.InstanceDiff, r *schema.Resource) {
}

// fixupAsSingleInstanceDiffOut modifies the given InstanceDiff in-place if any
// attributes in the schema have the AsSingle flag set, removing unneeded index
// steps from the flatmap keys for these so that they can be understood by the
// shim back to Terraform Core as a single nested value.
func fixupAsSingleInstanceDiffOut(id *terraform.InstanceDiff, r *schema.Resource) {
}

// fixupAsSingleConfigValueIn modifies the given "config value" in-place if
// any attributes in the schema have the AsSingle flag set, wrapping the given
// values for these in an extra level of slice so that they can be understood
// by legacy SDK code that'll be expecting to decode into a list/set.
//
// "Config value" for the purpose of this function has the same meaning as for
// the hcl2shims: a map[string]interface{} using the same subset of Go value
// types that would be generated by HCL/HIL when decoding a configuration in
// Terraform v0.11.
func fixupAsSingleConfigValueIn(c map[string]interface{}, s map[string]*schema.Schema) {
	for k, as := range s {
		if !as.AsSingle {
			continue // Don't touch non-AsSingle values at all. This is explicitly opt-in.
		}

		v, ok := c[k]
		if ok {
			c[k] = []interface{}{v}
		}

		if nr, ok := as.Elem.(*schema.Resource); ok {
			// Recursively fixup nested attributes too
			nm, ok := v.(map[string]interface{})
			if !ok {
				// Weird for a nested resource to not be a map, but we'll tolerate it rather than crashing
				continue
			}
			fixupAsSingleConfigValueIn(nm, nr.Schema)
		}
	}
}

// fixupAsSingleFlatmapKeyIn checks whether the given flatmap key passes through
// any schemas with AsSingle set, inserting artificial additional index steps
// so to allow the legacy SDK code to understand the result as a list or set.
// Returns the given key verbatim if no AsSingle attributes are encountered.
func fixupAsSingleFlatmapKeyIn(k string, r *schema.Resource) string {
	return k
}

// fixupAsSingleFlatmapKeyOut checks whether the given flatmap key passes through
// any schemas with AsSingle set, removing unneeded index steps to allow the
// shim back to Terraform Core to understand the result as a single nested
// value. Returns the given key verbatim if no AsSingle attributes are
// encountered.
func fixupAsSingleFlatmapKeyOut(k string, r *schema.Resource) string {
	return k
}
